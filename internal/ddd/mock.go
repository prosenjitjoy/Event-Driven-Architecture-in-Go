// Code generated by MockGen. DO NOT EDIT.
// Source: mall/internal/ddd (interfaces: Aggregate,CommandHandler,Entity,EventHandler,EventPublisher,EventSubscriber,ReplyHandler)
//
// Generated by this command:
//
//	mockgen -destination=mock.go -package=ddd mall/internal/ddd Aggregate,CommandHandler,Entity,EventHandler,EventPublisher,EventSubscriber,ReplyHandler
//

// Package ddd is a generated GoMock package.
package ddd

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockAggregate is a mock of Aggregate interface.
type MockAggregate struct {
	ctrl     *gomock.Controller
	recorder *MockAggregateMockRecorder
	isgomock struct{}
}

// MockAggregateMockRecorder is the mock recorder for MockAggregate.
type MockAggregateMockRecorder struct {
	mock *MockAggregate
}

// NewMockAggregate creates a new mock instance.
func NewMockAggregate(ctrl *gomock.Controller) *MockAggregate {
	mock := &MockAggregate{ctrl: ctrl}
	mock.recorder = &MockAggregateMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAggregate) EXPECT() *MockAggregateMockRecorder {
	return m.recorder
}

// AddEvent mocks base method.
func (m *MockAggregate) AddEvent(arg0 string, arg1 EventPayload, arg2 ...EventOption) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "AddEvent", varargs...)
}

// AddEvent indicates an expected call of AddEvent.
func (mr *MockAggregateMockRecorder) AddEvent(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddEvent", reflect.TypeOf((*MockAggregate)(nil).AddEvent), varargs...)
}

// AggregateName mocks base method.
func (m *MockAggregate) AggregateName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AggregateName")
	ret0, _ := ret[0].(string)
	return ret0
}

// AggregateName indicates an expected call of AggregateName.
func (mr *MockAggregateMockRecorder) AggregateName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AggregateName", reflect.TypeOf((*MockAggregate)(nil).AggregateName))
}

// ClearEvents mocks base method.
func (m *MockAggregate) ClearEvents() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ClearEvents")
}

// ClearEvents indicates an expected call of ClearEvents.
func (mr *MockAggregateMockRecorder) ClearEvents() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClearEvents", reflect.TypeOf((*MockAggregate)(nil).ClearEvents))
}

// GetEvents mocks base method.
func (m *MockAggregate) GetEvents() []AggregateEvent {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetEvents")
	ret0, _ := ret[0].([]AggregateEvent)
	return ret0
}

// GetEvents indicates an expected call of GetEvents.
func (mr *MockAggregateMockRecorder) GetEvents() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetEvents", reflect.TypeOf((*MockAggregate)(nil).GetEvents))
}

// ID mocks base method.
func (m *MockAggregate) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockAggregateMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockAggregate)(nil).ID))
}

// SetID mocks base method.
func (m *MockAggregate) SetID(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetID", arg0)
}

// SetID indicates an expected call of SetID.
func (mr *MockAggregateMockRecorder) SetID(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetID", reflect.TypeOf((*MockAggregate)(nil).SetID), arg0)
}

// SetName mocks base method.
func (m *MockAggregate) SetName(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetName", arg0)
}

// SetName indicates an expected call of SetName.
func (mr *MockAggregateMockRecorder) SetName(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetName", reflect.TypeOf((*MockAggregate)(nil).SetName), arg0)
}

// MockCommandHandler is a mock of CommandHandler interface.
type MockCommandHandler[T Command] struct {
	ctrl     *gomock.Controller
	recorder *MockCommandHandlerMockRecorder[T]
	isgomock struct{}
}

// MockCommandHandlerMockRecorder is the mock recorder for MockCommandHandler.
type MockCommandHandlerMockRecorder[T Command] struct {
	mock *MockCommandHandler[T]
}

// NewMockCommandHandler creates a new mock instance.
func NewMockCommandHandler[T Command](ctrl *gomock.Controller) *MockCommandHandler[T] {
	mock := &MockCommandHandler[T]{ctrl: ctrl}
	mock.recorder = &MockCommandHandlerMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandHandler[T]) EXPECT() *MockCommandHandlerMockRecorder[T] {
	return m.recorder
}

// HandleCommand mocks base method.
func (m *MockCommandHandler[T]) HandleCommand(ctx context.Context, cmd T) (Reply, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HandleCommand", ctx, cmd)
	ret0, _ := ret[0].(Reply)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HandleCommand indicates an expected call of HandleCommand.
func (mr *MockCommandHandlerMockRecorder[T]) HandleCommand(ctx, cmd any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleCommand", reflect.TypeOf((*MockCommandHandler[T])(nil).HandleCommand), ctx, cmd)
}

// MockEntity is a mock of Entity interface.
type MockEntity struct {
	ctrl     *gomock.Controller
	recorder *MockEntityMockRecorder
	isgomock struct{}
}

// MockEntityMockRecorder is the mock recorder for MockEntity.
type MockEntityMockRecorder struct {
	mock *MockEntity
}

// NewMockEntity creates a new mock instance.
func NewMockEntity(ctrl *gomock.Controller) *MockEntity {
	mock := &MockEntity{ctrl: ctrl}
	mock.recorder = &MockEntityMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEntity) EXPECT() *MockEntityMockRecorder {
	return m.recorder
}

// EntityName mocks base method.
func (m *MockEntity) EntityName() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EntityName")
	ret0, _ := ret[0].(string)
	return ret0
}

// EntityName indicates an expected call of EntityName.
func (mr *MockEntityMockRecorder) EntityName() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EntityName", reflect.TypeOf((*MockEntity)(nil).EntityName))
}

// ID mocks base method.
func (m *MockEntity) ID() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(string)
	return ret0
}

// ID indicates an expected call of ID.
func (mr *MockEntityMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockEntity)(nil).ID))
}

// SetID mocks base method.
func (m *MockEntity) SetID(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetID", arg0)
}

// SetID indicates an expected call of SetID.
func (mr *MockEntityMockRecorder) SetID(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetID", reflect.TypeOf((*MockEntity)(nil).SetID), arg0)
}

// SetName mocks base method.
func (m *MockEntity) SetName(arg0 string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetName", arg0)
}

// SetName indicates an expected call of SetName.
func (mr *MockEntityMockRecorder) SetName(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetName", reflect.TypeOf((*MockEntity)(nil).SetName), arg0)
}

// MockEventHandler is a mock of EventHandler interface.
type MockEventHandler[T Event] struct {
	ctrl     *gomock.Controller
	recorder *MockEventHandlerMockRecorder[T]
	isgomock struct{}
}

// MockEventHandlerMockRecorder is the mock recorder for MockEventHandler.
type MockEventHandlerMockRecorder[T Event] struct {
	mock *MockEventHandler[T]
}

// NewMockEventHandler creates a new mock instance.
func NewMockEventHandler[T Event](ctrl *gomock.Controller) *MockEventHandler[T] {
	mock := &MockEventHandler[T]{ctrl: ctrl}
	mock.recorder = &MockEventHandlerMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventHandler[T]) EXPECT() *MockEventHandlerMockRecorder[T] {
	return m.recorder
}

// HandleEvent mocks base method.
func (m *MockEventHandler[T]) HandleEvent(ctx context.Context, event T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HandleEvent", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// HandleEvent indicates an expected call of HandleEvent.
func (mr *MockEventHandlerMockRecorder[T]) HandleEvent(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleEvent", reflect.TypeOf((*MockEventHandler[T])(nil).HandleEvent), ctx, event)
}

// MockEventPublisher is a mock of EventPublisher interface.
type MockEventPublisher[T Event] struct {
	ctrl     *gomock.Controller
	recorder *MockEventPublisherMockRecorder[T]
	isgomock struct{}
}

// MockEventPublisherMockRecorder is the mock recorder for MockEventPublisher.
type MockEventPublisherMockRecorder[T Event] struct {
	mock *MockEventPublisher[T]
}

// NewMockEventPublisher creates a new mock instance.
func NewMockEventPublisher[T Event](ctrl *gomock.Controller) *MockEventPublisher[T] {
	mock := &MockEventPublisher[T]{ctrl: ctrl}
	mock.recorder = &MockEventPublisherMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventPublisher[T]) EXPECT() *MockEventPublisherMockRecorder[T] {
	return m.recorder
}

// Publish mocks base method.
func (m *MockEventPublisher[T]) Publish(ctx context.Context, events ...T) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range events {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Publish", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockEventPublisherMockRecorder[T]) Publish(ctx any, events ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, events...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventPublisher[T])(nil).Publish), varargs...)
}

// MockEventSubscriber is a mock of EventSubscriber interface.
type MockEventSubscriber[T Event] struct {
	ctrl     *gomock.Controller
	recorder *MockEventSubscriberMockRecorder[T]
	isgomock struct{}
}

// MockEventSubscriberMockRecorder is the mock recorder for MockEventSubscriber.
type MockEventSubscriberMockRecorder[T Event] struct {
	mock *MockEventSubscriber[T]
}

// NewMockEventSubscriber creates a new mock instance.
func NewMockEventSubscriber[T Event](ctrl *gomock.Controller) *MockEventSubscriber[T] {
	mock := &MockEventSubscriber[T]{ctrl: ctrl}
	mock.recorder = &MockEventSubscriberMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventSubscriber[T]) EXPECT() *MockEventSubscriberMockRecorder[T] {
	return m.recorder
}

// Subscribe mocks base method.
func (m *MockEventSubscriber[T]) Subscribe(handler EventHandler[T], events ...string) {
	m.ctrl.T.Helper()
	varargs := []any{handler}
	for _, a := range events {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Subscribe", varargs...)
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockEventSubscriberMockRecorder[T]) Subscribe(handler any, events ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{handler}, events...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventSubscriber[T])(nil).Subscribe), varargs...)
}

// MockReplyHandler is a mock of ReplyHandler interface.
type MockReplyHandler[T Reply] struct {
	ctrl     *gomock.Controller
	recorder *MockReplyHandlerMockRecorder[T]
	isgomock struct{}
}

// MockReplyHandlerMockRecorder is the mock recorder for MockReplyHandler.
type MockReplyHandlerMockRecorder[T Reply] struct {
	mock *MockReplyHandler[T]
}

// NewMockReplyHandler creates a new mock instance.
func NewMockReplyHandler[T Reply](ctrl *gomock.Controller) *MockReplyHandler[T] {
	mock := &MockReplyHandler[T]{ctrl: ctrl}
	mock.recorder = &MockReplyHandlerMockRecorder[T]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockReplyHandler[T]) EXPECT() *MockReplyHandlerMockRecorder[T] {
	return m.recorder
}

// HandleReply mocks base method.
func (m *MockReplyHandler[T]) HandleReply(ctx context.Context, reply T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HandleReply", ctx, reply)
	ret0, _ := ret[0].(error)
	return ret0
}

// HandleReply indicates an expected call of HandleReply.
func (mr *MockReplyHandlerMockRecorder[T]) HandleReply(ctx, reply any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HandleReply", reflect.TypeOf((*MockReplyHandler[T])(nil).HandleReply), ctx, reply)
}
